/**
 * NssSpillInfo implementation file
 * $Id: NssSpillInfo.cpp,v 1.15 2019/01/25 21:10:29 lackey32 Exp $
 */
#include "NssSpillInfo.h"
#include <iostream>

using namespace nova::NovaSpillServer;

NssSpillInfo::NssSpillInfo(uint64_t const time, int const type) :
_spilltime(time)
{
  if (_checkSpillTypeRange(type)) {
    _spilltype = static_cast<SpillType>(type);
  }
  else {
    _spilltype = kTestConnection;
    //log error
  }
}

bool NssSpillInfo::_checkSpillTypeRange(int const type) {
  return (type>=0 && type < kNSpillType);
}

bool NssSpillInfo::getSpillTypeFromEvent(SpillType& type,
                                         uint16_t const evt) {
  type = kFake;
  if (evt & (1<<15)) { //parity error
    //can't reliably determine the type. Waste this spill.
    type = kFake;
    return false;
  }

  if (evt & (1<<9)) { //MIBS
    if ((evt & (0xFF)) == 0x74) {
      type = kNuMI;
      return true;
    } else {
      std::cout << "Unexpected event number for MIBS event: " << evt << std::endl;
      type = kFake;
      return false;
    }
  }
  if (evt & (1<<10)) { //BNB
    if ((evt & (0xFF)) == 0x1B) {
      type = kBNB;
      return true;
    } else {
      std::cout << "Unexpected event number for BNB event" << evt << std::endl;
      type = kFake;
      return false;
    }
  }

  //TCLK, need to find type from TCLK number, possibly do logic
  //TCLK signals have a jitter of up to 1 microsecond (due to encoding)
  // (from Greg Vogel, 2/22/2010)
  if (evt & (1<<8)) { //TCLK
    if ((evt & 0xFF) == 0x1D) {
      // "Booster Reset for MiniBooNe Beam Cycle";
      // generated at GMPS BMIN Delayed; permanently enabled
      // Booster reset: expect 1F in 35 millisec
      // form window 15ms wide, 25ms after 1D
      type = kBNBtclk;
      return true;
    }

    if ((evt & 0xFF) == 0x1F) {
      // "Booster Extraction Sync (BES) for a Beam Cycle";
      // generated by a BES during a Booster beam cycle
      // Booster extraction sync.: expect beam in 320 microsec.
      // issue kBNB with 315 microsec delay if inside 1D window
      type = kBNBtclk;
      return true;
    }
    if ((evt & 0xFF) == 0xAD) {
      //NUMI Reset for Mixed Mode Beamline Ramp
      //Want to pretty much ignore this.
      type = kNuMItclk;
      return true;
    }
    if ((evt & 0xFF) == 0xA9) {
      //TCLK reflection of MIBS $74: 120Gev Proton Extraction from MI to NUMI
      //This is the one to use.
      type = kNuMItclk;
      return true;
    }
    if ((evt & 0xFF) == 0x8F) {
      //TCLK 1 Hz pulser
      type = kAccelOneHztclk;
      return true;
    }
    if ((evt & 0xff) == 0x00) {
      //Super Cylce and master clock reset
      type = kSuperCycle;
      return true;
    }
    if ((evt & 0xff) == 0xA4) {
      //NuMI cycle sample trigger; $A5 reference
      type = kNuMISampleTrig;
      return true;
    }
    if ((evt & 0xff) == 0xA5) {
      //NuMI reset for beam
      type = kNuMIReset;
      return true;
    }
    if ((evt & 0xff) == 0x39) {
      //test beam spill
      type = kTBSpill;
      return true;
    }
  }
  return true;
}

int NssSpillInfo::getSpillTypeFromName(std::string const& name)
{
  int ret = -1;
#define NAME_CHECK(arg) if(name == #arg) ret = k##arg;
  NAME_CHECK(NuMI);
  NAME_CHECK(BNB);
  NAME_CHECK(NuMItclk);
  NAME_CHECK(BNBtclk);
  NAME_CHECK(AccelOneHztclk);
  NAME_CHECK(Fake);
  NAME_CHECK(TestConnection);
  NAME_CHECK(SuperCycle);
  NAME_CHECK(NuMISampleTrig);
  NAME_CHECK(NuMIReset);
  NAME_CHECK(TBSpill);
  NAME_CHECK(TBTrig);
#undef NAME_CHECK
  return ret;
}

std::string NssSpillInfo::getSpillNameFromType(int type)
{
  std::string ret = "Undefined";
#define NAME_CHECK(arg) if(type == k##arg) ret = #arg;
  NAME_CHECK(NuMI);
  NAME_CHECK(BNB);
  NAME_CHECK(NuMItclk);
  NAME_CHECK(BNBtclk);
  NAME_CHECK(AccelOneHztclk);
  NAME_CHECK(Fake);
  NAME_CHECK(TestConnection);
  NAME_CHECK(SuperCycle);
  NAME_CHECK(NuMISampleTrig);
  NAME_CHECK(NuMIReset);
  NAME_CHECK(TBSpill);
  NAME_CHECK(TBTrig);
#undef NAME_CHECK
  return ret;
}

std::list< int > NssSpillInfo::allSpillTypes() {
  std::list< int > l;
  for (int i = 0; i!= kNSpillType; ++i) l.push_back(i);
  return l;
}

void NssSpillInfo::set (uint64_t const time, int const type)
{
  _spilltime = time;
  if (_checkSpillTypeRange(type)) {
    _spilltype = static_cast<SpillType>(type);
  }
  else {
    _spilltype = kTestConnection;
    //log error
  }
}
